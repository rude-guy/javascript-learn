<script>
  function SuperType(name) {
    this.name = name;
    this.nums = [1, 2, 3];
  }
  SuperType.prototype.sayName = function () {
    console.log(this.name);
  };
  function Subtype(name, age) {
    SuperType.call(this, name); // 1
    this.age = age;
  }

  Subtype.prototype = new SuperType(); // 2

  Subtype.prototype.sayAge = function () {
    console.log(this.age);
  };

  let instance1 = new Subtype('xiaoming', 20);
  instance1.nums.push(4);
  console.log(instance1.nums); // [1, 2, 3, 4]
  instance1.sayName(); // 'xiaoming'
  instance1.sayAge(); // 20

  let instance2 = new Subtype('xiaohong', 25);
  console.log(instance2.nums); // [1, 2, 3]
  instance2.sayName(); // 'xiaohong'
  instance2.sayAge(); // 25

  // 组合继承弥补了原型链和盗用构造函数的不足，时JavaScript中使用最多的继承模式。
  // 组合继承也保留了`instanceof`操作符和`isPrototypeof()`方法识别合成对象的能力

  // 缺点：父类构造器始终会被调用两次，一次是创建子类原型时调用，另一次时在子类构造函数中调用
</script>
